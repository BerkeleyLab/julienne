Getting Started
===============

Writing tests
-------------
This `demo` directory contains a demonstration project with stub types and
functions in the `src` subdirectory and tests for those stubs in the `test`
subdirectory.  Please review the contents and try 
[running the demonstration tests] and [generating test scaffolding].
Julienne's `scaffold` program follows the steps that you would take to
write a tests and a test driver program manually:

1. Define a non-abstract child type extending Julienne's `test_t` type.  Please
   see, for example, the `speciment_test_t` type in the [`specimen_test_m`] module
2. Define functions implementing the inherited parent type's deferred bindings:
   a. A `subject` function constructing a `character` result describing
      what is being tested, such as a derived type or a module.  For example,
      please see the [`subject`] function in the demonstration test suite
   b. A `result` function that tests the test subject and constructs a 
      `test_diagnosis_t` result by passing an array of `test_description_t`
      objects to `test_t`'s type-bound `run` function. Please see, for example,
      the `result` function in `demo/test/specimen_test_m`.
3. Write diagnosis functions that take no arguments, perform checks, and that
   each construct a `test_diagnosis_t` result by using a Julienne idiom or by
   invoking a `test_diagnosis_t` user-defined structure constructor.  Please see
   for example, the `check_something` function in the [`specimen_test_m`] module.
4. Write a driver program that constructs a `test_harness_t` object from an array
   of `text_fixture_t` objects, each of which is constructed from a `test_t`
   child type structure constructor.  Please see the demonstration [driver].

Running the demonstration tests
-------------------------------
With the Fortran Package Manager (`fpm`) installed, please set Julienne's
`demo` subdirectory as your present working directory in a shell and try
running the demonstration test suite using the command corresponding to
your compiler in the table below.

|Vendor | Version(s) Tested       | Example shell command                            |
|-------|-------------------------|--------------------------------------------------|
|LLVM   | 20.1.8                  | `fpm test --compiler flang-new --flag "-O3"`     |
|GCC    | 14.3.0, 15.1.0          | `fpm test --compiler gfortran --profile release` |
|NAG    | 7.2 Build 7235          | `fpm test --compiler nagfor --flag -fpp`         |
|Intel  | 2025.1.0 Build 20250728 | `fpm test --compiler ifx --flag "-fpp -O3"`      |

Generating test scaffolding
---------------------------
The tests Julienne's `demo/test` were generated by first creating a
`test-suite.json` file with the following contents:
```
{
    "test suite": {
        "test subjects" : ["specimen","widget"]
    }
}
```
Julienne's current file reader is fragile so it is recommended to maintain the
above structure after renaming and expanding the array of test subjects, keeping
the array on one line.

The test modules and test driver program in `demo/test` were created by
entering the following command in a `zsh` shell with the present working
directory set to the root of Julienne's source tree:
```
fpm run scaffold \
  --compiler flang-new \
  -- --json-file demo/test-suite.json \
  --suite-path demo/test
```
which generates the following directory tree and files inside `demo`:
```
demo
├── src
│   ├── specimen_m.f90
│   └── widget_m.f90
├── test
    ├── driver.f90
    ├── specimen_test_m.f90
    └── widget_test_m.f90
```
The modules inside the `specimen_test_m.f90` and `widget_test_m.f90` files each
contain three tests: 
1. One test intentionally fails and demonstrates the construction of a test
   diagnosis via an idiom using Julienne's defined operations:
   ```
   test_diagnosis = .all.([22./7., 3.14159] .approximates. pi .within. 0.001)
   ```
   The resulting failure of the first approximation (`22./7.`) generates a
   diagnostic message for that approximation only.
2. Another test demonstrates the use of the `test_diagnosis_t()` user-defined
   structure construtor, which supports tasks that cannot be conveniently
   expressed with the operators defined in the README.md file in the root of
   Julienne's source tree.
   ```
   test_diagnosis = test_diagnosis_t(test_passed = 1 == 1, diagnostics_string = 'craziness ensued')

   ```
3. A third test demonstrates how to skip a test by not including a diagosis
   function in the correspoding test description, which is useful when a test
   is known to crash with a specific build configuration for example.

Forming diagnostic strings
--------------------------
Julienne provides string-manipulation utilities to support the construction of
the `test_diagnosis_t` constructor's `diagnostics_string` arugment.  The
`string_t` generic interface can be used to invoke various specific functions,
each of which takes an argument of a different data type, kind, or rank (TKR)
and defines a `string_t` result encapsulating a `character` representation of
the function argument.  For the currently supported TKR, please see Julienne's
online [documentation](https://berkeleylab.github.io/julienne).

An especially useful pattern for forming diagnostic strings involves invoking
Julienne's `operator(.csv.)` to form a string of comma-separated values (CSV)
from a one-dimensional (1D) array.  For example, consider the following test
description:
```fortran
  test_description_t("returning the counting numbers up to 3", check_counting_numbers)
```
and the following corresponding test:
```fortran
  function check_counting_numbers()
     integer, parameter :: expected_array(*) = [1, 2, 3]

     associate(actual_array => counting_numbers(max=3))
       test_diagnosis = test_diagnosis_t( &
          test_passed = all(expected_array == actual_array) &
         ,diagnostics_string = "expected " // .csv. string_t(expected_array) // "; actual  // .csv. string_t(actual_array) &
       )
     end associate
  end function
```
If the `counting_numbers` result contains all zeros, the test report would
include the following text:
```
FAILS  on returning the counting numbers up to 3
      diagnostics: expected 1,2,3; actual 0,0,0
```
To support a common array notation, Julienne also supports bracketing strings.

Diagnosis Functions
-------------------
The Unified Modeling Language ([UML]) class diagram below depicts the class
relationships involved in making the above example work:

```mermaid
 %%{init: { 'theme':'default',  "class" : {"hideEmptyMembersBox": true} } }%%
classDiagram

class test_t{
    <<abstract>>
    subject() character(len=:) *
    results() test_result_t[0..*] *
    report(passes : integer, tests : integer, skips : integer)
}
test_t --> specimen_test_t : report() invokes subject() and results()

class specimen_test_t{
    subject() character(len=:)
    results() test_result_t[0..*]
}
specimen_test_t --|> test_t : extends and implements
specimen_test_t --> test_description_t : results() constructs local array of
specimen_test_t --> test_description_t : results() invokes run() on

class test_description_t{
    test_description_t(description : string_t, diagnosis_function : diagnosis_function_i)
    run() test_result_t
}
test_description_t --> test_diagnosis_t : run() invokes diagnosis_function to construct
test_description_t --> test_result_t : run() constructs with test_diagnosis_t object

class test_result_t{
    test_result_t(test_passed : logical, diagnosis : test_diagnosis_t)
}

class test_diagnosis_t{
    test_diagnosis_t(test_passed : logical, diagnostics_string : string_t)
}
```

Skipping Tests
--------------
When a test is known to cause a compile-time or runtime crash in a specific
scenario, e.g., with a specific compiler or compiler version, including that
test will prevent the test suite from building or running to completion.  It
can be useful to skip a test with the problematic compiler but to report the
test as skipped and account for the skipped tests in the tally of test results.
For this purpose, the `test_description_t` constructor function has an optional
`diagnosis_function` argument.  When these arguments are not `present`, the
`test_t`'s `report` procedure will report the test as skipped but will terminate
normally as long as the sum of the passing tests and skipped tests equals the
total number of tests.  One might accomplish this with the compiler's predefined
preprocessor macro:
```
#ifndef __GFORTRAN__
      ,test_description_t('constructing bracketed strings', brackets_strings_ptr) &
#else
      ,test_description_t('constructing bracketed strings'                      ) &
#endif
```
which presently appears in Julienne `test/string_test_m.f90` test in order to
work around a runtime crash known to be caused by a `gfortran` bug.

String_t Functions
------------------
Because of the central role that `string_t` type-bound procedures play in
defining diagnostics strings, we list most of these procedures in the class
diagram below.

```mermaid
classDiagram

class string_t{
    string_t(integer) string_t
    string_t(logical) string_t
    string_t(logical(c_bool)) string_t
    string_t(real) string_t
    string_t(double precision) string_t
    string_t(character(len=*)) string_t
    string_t(complex) string_t
    string_t(complex(kind(1D0))) string_t

    operator(//)(string_t, string_t)
    operator(//)(string_t, character(len=*))
    operator(//)(character(len=*), string_t)

    operator(.csv.)(string_t) string_t
    operator(.csv.)(character(len=*)) string_t
    operator(.sv.)(strings : string_t[1..*], separator : characer(len=*)) string_t
    operator(.sv.)(strings : character(len=*)[1..*], separator : characer(len=*)) string_t
    operator(.sv.)(strings : string_t[1..*], separator : string_t) string_t

    array_of_strings(delimited_strings : character(len=*), delimiter : character(len=*))
    file_extension(string_t) string_t
    base_name(string_t) string_t
}
```

[UML]: https://wikipedia.org/Unified_modeling_langauge)
[running the demonstration tests]: #running-the-demonstration-tests
[generating test scaffolding]: #generating-test-scaffolding
[`speciment_test_t`]: ./demo/test/specimen_test_m.f90
[`specimen_test_m`]: ./demo/test/specimen_test_m.f90
[`subject`]: ./demo/test/specimen_test_m.f90
[`result`]: ./demo/test/specimen_test_m.f90
[`specimen_test_m`]: ./demo/test/specimen_test_m.f90
[driver]: ./demo/test/driver.f90
